#!/usr/bin/env python

"""
This script aims to make it more convenient to run various tests using
different configs.
"""
import os
import shlex
import subprocess as sp
import sys
from pathlib import Path
import argparse
import yaml

HERE = Path(__file__).resolve().parent
TOPLEVEL = Path(__file__).resolve().parent.parent

WORKFLOW_ARGS = yaml.safe_load(open(TOPLEVEL / "test" / "workflow_test_params.yaml"))


def print_header(name):
    print("-" * 80)
    print("lcdb-wf-test: ", name)
    print("-" * 80)


class Runner(object):
    """
    To add a new command, create a new method with a name starting with
    "_cmd_", create a new ArgumentParser.
    """

    default_env = os.getenv("LCDBWF_ENV", str(TOPLEVEL / "env"))
    default_env_r = os.getenv("LCDBWF_ENV_R", str(TOPLEVEL / "env-r"))
    global_parser = argparse.ArgumentParser(add_help=False)
    global_parser.add_argument(
        "--env", default=default_env,
        help=f"""Main conda environment to use. Override
        by setting $LCDBWF_ENV or override that by explicity setting --env. Currently will use {default_env}"""
    )
    global_parser.add_argument(
        "--env-r",
        default=default_env_r,
        help=f"""Main R conda environment to use. Override by setting
        $LCDBWF_ENV_R or override that by explicity setting --env-r. Currently
        will use {default_env_r}"""
    )
    global_parser.add_argument(
        "--orig",
        default=str(TOPLEVEL),
        help=f"""If specified, you can use the special string '__ORIG__' in
        command line arguments which will be filled in with the value provided
        here. Mostly used in CI.""",
    )

    def __init__(self):
        parser = argparse.ArgumentParser(
            description="Test runner for lcdb-wf",
        )

        choices = [i.replace("_cmd_", "") for i in dir(self) if i.startswith("_cmd_")]

        parser.add_argument("command", help="Subcommand to run", choices=choices)
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, "_cmd_" + args.command):
            print("Unrecognized command")
            parser.print_help()
            sys.exit(1)
        getattr(self, "_cmd_" + args.command)()

    def _cmd_data(self):
        parser = argparse.ArgumentParser(
            description="Download data",
            parents=[self.global_parser],
        )

        parser.add_argument(
            "--kind",
            default="all",
            choices=["rnaseq", "chipseq"],
            help="Kind of data to download",
        )
        parser.add_argument(
            "--branch", default="master", help="Branch from lcdb-test-data to use"
        )
        parser.add_argument(
            "--verbose",
            action="store_true",
            help="Be verbose about what's being downloaded",
        )

        args = parser.parse_args(sys.argv[2:])

        repo = "lcdb-test-data"
        URL = f"https://github.com/lcdb/{repo}/blob/{args.branch}/data/{{}}?raw=true"

        # This dict maps files in the `data` directory of the repo to a local
        # path to which it should be downloaded.
        data_files = {
            "rnaseq": [
                (
                    "rnaseq_samples/sample1/sample1.small_R1.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample1.fq.gz",
                ),
                (
                    "rnaseq_samples/sample2/sample2.small_R1.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample2.fq.gz",
                ),
                (
                    "rnaseq_samples/sample3/sample3.small_R1.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample3.fq.gz",
                ),
                (
                    "rnaseq_samples/sample4/sample4.small_R1.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample4.fq.gz",
                ),
                (
                    "rnaseq_samples/sample1/sample1.small_R1.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample1PE_1.fq.gz",
                ),
                (
                    "rnaseq_samples/sample1/sample1.small_R2.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample1PE_2.fq.gz",
                ),
                (
                    "rnaseq_samples/sample2/sample2.small_R1.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample2PE_1.fq.gz",
                ),
                (
                    "rnaseq_samples/sample2/sample2.small_R2.fastq.gz",
                    "workflows/rnaseq/data/example_data/rnaseq_sample2PE_2.fq.gz",
                ),
            ],
            "chipseq": [
                (
                    "chipseq_samples/input_1/input_1.tiny_R1.fastq.gz",
                    "workflows/chipseq/data/example_data/chipseq_input1.fq.gz",
                ),
                (
                    "chipseq_samples/input_2/input_2.tiny_R1.fastq.gz",
                    "workflows/chipseq/data/example_data/chipseq_input2.fq.gz",
                ),
                (
                    "chipseq_samples/input_3/input_3.tiny_R1.fastq.gz",
                    "workflows/chipseq/data/example_data/chipseq_input3.fq.gz",
                ),
                (
                    "chipseq_samples/ip_1/ip_1.tiny_R1.fastq.gz",
                    "workflows/chipseq/data/example_data/chipseq_ip1.fq.gz",
                ),
                (
                    "chipseq_samples/ip_2/ip_2.tiny_R1.fastq.gz",
                    "workflows/chipseq/data/example_data/chipseq_ip2.fq.gz",
                ),
                (
                    "chipseq_samples/ip_3/ip_3.tiny_R1.fastq.gz",
                    "workflows/chipseq/data/example_data/chipseq_ip3.fq.gz",
                ),
                (
                    "chipseq_samples/ip_4/ip_4.tiny_R1.fastq.gz",
                    "workflows/chipseq/data/example_data/chipseq_ip4.fq.gz",
                ),
            ],
        }

        if args.kind == "all":
            kinds = list(data_files.keys())
        else:
            kinds = [args.kind]
        for kind in kinds:
            for fn, dest in data_files[kind]:
                url = URL.format(fn)
                if args.verbose:
                    print(f"downloading {url}")
                if dest is None:
                    dest = fn
                dest = Path(dest)
                dest.parent.mkdir(parents=True, exist_ok=True)
                sp.run(
                    f"wget -q -O- {url} > {dest}", shell=True, check=True, cwd=TOPLEVEL
                )

    def _cmd_unit_tests(self):
        parser = argparse.ArgumentParser(
            description="Run various unit tests and checks",
            parents=[self.global_parser],
        )
        parser.add_argument(
            "--pytest",
            action="store_true",
            help="Run pytest unit tests and module doctests on lib/ directory",
        )
        parser.add_argument(
            "--url-check",
            action="store_true",
            help="Ensure that URLs found in config files (e.g., to genome references) are still valid",
        )
        parser.add_argument(
            "--r-test",
            action="store_true",
            help="""Run devtools::test on the lcdbwf R package. Activates the
            conda environment specified by --env-r just before running.""",
        )

        parser.add_argument(
            "--ensure-docs",
            action="store_true",
            help="Ensure that all named R chunks are documented in the online help docs",
        )

        args = parser.parse_args(sys.argv[2:])

        if args.pytest:
            print_header("pytest")
            sp.run(["pytest", "--doctest-modules", "lib"], check=True, cwd=TOPLEVEL)

        if args.url_check:
            print_header("url check")
            sys.path.insert(0, str(TOPLEVEL))
            from lib.common import check_all_urls_found

            check_all_urls_found()

        if args.r_test:
            print_header("R test")
            sp.run(
                'eval "$(conda shell.bash hook)" '
                f"&& conda activate {args.env_r} "
                '''&& Rscript -e "devtools::test('lib/lcdbwf', export_all=TRUE)"''',
                shell=True,
                check=True,
                executable="/bin/bash"
            )

        if args.ensure_docs:
            sp.run(["./ensure_docs.py"], check=True, cwd=TOPLEVEL / "ci")

    def _cmd_rnaseq(self):
        """
        This function handles the "rnaseq" subcommand.
        """

        parser = argparse.ArgumentParser(
            description="Run rnaseq workflow and downstream tests",
            parents=[self.global_parser],
        )
        parser.add_argument(
            "--run-workflow",
            action="store_true",
            help="""Run rnaseq workflow using the run_tesh.sh harness, which
            edits the Snakefile to use test settings before running. Additional
            args not specified here are passed to Snakemake, or use other flags
            below to easily specify config sets.""",
        )
        parser.add_argument(
            "--trackhub", action="store_true", help="Build the rnaseq track hub"
        )
        parser.add_argument(
            "--downstream",
            action="store_true",
            help="""Run the downstream rnaseq.Rmd, via
            workflows/rnaseq/run_downstream_test.sh. This runs the preprocessor
            on the files to allow the use of # [TEST SETTINGS] comments; see
            that script for details. Activates environment configured in
            --env-r before running.""",
        )

        # Here we programmatically build the parser from the
        # workflow_test_params.yaml file. They are added to
        # a mutually-exclusive group to avoid overwriting each others' config
        # file params. They all write their params to the args.additional_args
        # attribute.
        group = parser.add_mutually_exclusive_group()
        workflow_prefix = "bash run_test.sh"
        workflow_dir = "workflow/rnaseq"
        for key, val in WORKFLOW_ARGS["rnaseq"].items():
            group.add_argument(
                "--" + key,
                action="store_const",
                default="",
                dest="additional_args",
                const=val["args"],
                help=f"""GROUP: Part of mutually exclusive rnaseq group. Runs
                the following: cd {workflow_dir} && {workflow_prefix}
                {val['args']}. {val['desc']} Configured in
                workflow_test_params.yaml.""",
            )

        args, extra = parser.parse_known_args(sys.argv[2:])

        if args.run_workflow:
            print(args)
            if args.additional_args:
                extra.extend(shlex.split(args.additional_args))

            extra = [i.replace("__ORIG__", args.orig) for i in extra]
            strargs = " ".join(extra)
            print_header(f"Running workflows/rnaseq/run_test.sh with args: {strargs}")
            sp.run(
                shlex.split(workflow_prefix) + extra,
                cwd=TOPLEVEL / "workflows/rnaseq",
                check=True,
            )
        if args.trackhub:
            print_header("running trackhub script")
            sp.run(
                [
                    "python",
                    "rnaseq_trackhub.py",
                    "config/config.yaml",
                    "config/hub_config.yaml",
                ],
                check=True,
                cwd="workflows/rnaseq",
            )
            print("See workflows/rnaseq/staging for the built trackhub")

        if args.downstream:
            print_header("running downstream rnaseq.Rmd")
            sp.run(
                'eval "$(conda shell.bash hook)" '
                f"&& conda activate {args.env_r} "
                "&& (cd workflows/rnaseq && bash run_downstream_test.sh)",
                shell=True,
                check=True,
                executable="/bin/bash"
            )


if __name__ == "__main__":
    Runner()

if __name__ == "__mn__":
    if args.references:
        print_header("references")
        snakefile(
            "workflows/references",
            snakemake_args=[
                "--use-conda",
                "-j",
                args.cpus,
                "-k",
                "-p",
                "-r",
                "--configfile",
                "config/config.yaml",
            ],
        )
# vim: ft=python
